/**
 * Streakify API
 * No descripton provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * 
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as querystring from "querystring";
import * as url from "url";

import * as isomorphicFetch from "isomorphic-fetch";
import * as assign from "core-js/library/fn/object/assign";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "https://localhost:8080/";

export interface FetchArgs {
    url: string;
    options: any; 
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
}

export interface Streak {
    "description"?: string;
    "id"?: number;
    "name"?: string;
    "user"?: User;
}

export interface StreakEntry {
    "end"?: Date;
    "id"?: number;
    "start"?: Date;
    "title"?: string;
}

export interface User {
    "email"?: string;
    "id"?: number;
    "name"?: string;
}



/**
 * StreakcontrollerApi - fetch parameter creator
 */
export const StreakcontrollerApiFetchParamCreactor = {
    /** 
     * all
     */
    allUsingGET(): FetchArgs {
        const baseUrl = `/streaks`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * delete
     * @param id id
     */
    deleteUsingDELETE(params: {  id: number; }): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteUsingDELETE");
        }
        const baseUrl = `/streaks/{id}`
            .replace(`{${"id"}}`, `${ params.id }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * get
     * @param id id
     */
    getUsingGET(params: {  id: number; }): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getUsingGET");
        }
        const baseUrl = `/streaks/{id}`
            .replace(`{${"id"}}`, `${ params.id }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * save
     * @param streak streak
     */
    saveUsingPOST(params: {  streak: Streak; }): FetchArgs {
        // verify required parameter "streak" is set
        if (params["streak"] == null) {
            throw new Error("Missing required parameter streak when calling saveUsingPOST");
        }
        const baseUrl = `/streaks`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["streak"]) {
            fetchOptions.body = JSON.stringify(params["streak"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * StreakcontrollerApi - functional programming interface
 */
export const StreakcontrollerApiFp = {
    /** 
     * all
     */
    allUsingGET(): (fetch: FetchAPI, basePath?: string) => Promise<Array<Streak>> {
        const fetchArgs = StreakcontrollerApiFetchParamCreactor.allUsingGET();
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * delete
     * @param id id
     */
    deleteUsingDELETE(params: { id: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StreakcontrollerApiFetchParamCreactor.deleteUsingDELETE(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * get
     * @param id id
     */
    getUsingGET(params: { id: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<Streak> {
        const fetchArgs = StreakcontrollerApiFetchParamCreactor.getUsingGET(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * save
     * @param streak streak
     */
    saveUsingPOST(params: { streak: Streak;  }): (fetch: FetchAPI, basePath?: string) => Promise<Streak> {
        const fetchArgs = StreakcontrollerApiFetchParamCreactor.saveUsingPOST(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * StreakcontrollerApi - object-oriented interface
 */
export class StreakcontrollerApi extends BaseAPI {
    /** 
     * all
     */
    allUsingGET() {
        return StreakcontrollerApiFp.allUsingGET()(this.fetch, this.basePath);
    }
    /** 
     * delete
     * @param id id
     */
    deleteUsingDELETE(params: {  id: number; }) {
        return StreakcontrollerApiFp.deleteUsingDELETE(params)(this.fetch, this.basePath);
    }
    /** 
     * get
     * @param id id
     */
    getUsingGET(params: {  id: number; }) {
        return StreakcontrollerApiFp.getUsingGET(params)(this.fetch, this.basePath);
    }
    /** 
     * save
     * @param streak streak
     */
    saveUsingPOST(params: {  streak: Streak; }) {
        return StreakcontrollerApiFp.saveUsingPOST(params)(this.fetch, this.basePath);
    }
};

/**
 * StreakcontrollerApi - factory interface
 */
export const StreakcontrollerApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * all
         */
        allUsingGET() {
            return StreakcontrollerApiFp.allUsingGET()(fetch, basePath);
        },
        /** 
         * delete
         * @param id id
         */
        deleteUsingDELETE(params: {  id: number; }) {
            return StreakcontrollerApiFp.deleteUsingDELETE(params)(fetch, basePath);
        },
        /** 
         * get
         * @param id id
         */
        getUsingGET(params: {  id: number; }) {
            return StreakcontrollerApiFp.getUsingGET(params)(fetch, basePath);
        },
        /** 
         * save
         * @param streak streak
         */
        saveUsingPOST(params: {  streak: Streak; }) {
            return StreakcontrollerApiFp.saveUsingPOST(params)(fetch, basePath);
        },
    }
};


/**
 * StreakentrycontrollerApi - fetch parameter creator
 */
export const StreakentrycontrollerApiFetchParamCreactor = {
    /** 
     * all
     */
    allUsingGET1(): FetchArgs {
        const baseUrl = `/entries`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * delete
     * @param id id
     */
    deleteUsingDELETE1(params: {  id: number; }): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteUsingDELETE1");
        }
        const baseUrl = `/entries/{id}`
            .replace(`{${"id"}}`, `${ params.id }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * save
     * @param entry entry
     */
    saveUsingPOST1(params: {  entry: StreakEntry; }): FetchArgs {
        // verify required parameter "entry" is set
        if (params["entry"] == null) {
            throw new Error("Missing required parameter entry when calling saveUsingPOST1");
        }
        const baseUrl = `/entries`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["entry"]) {
            fetchOptions.body = JSON.stringify(params["entry"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * StreakentrycontrollerApi - functional programming interface
 */
export const StreakentrycontrollerApiFp = {
    /** 
     * all
     */
    allUsingGET1(): (fetch: FetchAPI, basePath?: string) => Promise<Array<StreakEntry>> {
        const fetchArgs = StreakentrycontrollerApiFetchParamCreactor.allUsingGET1();
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * delete
     * @param id id
     */
    deleteUsingDELETE1(params: { id: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StreakentrycontrollerApiFetchParamCreactor.deleteUsingDELETE1(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * save
     * @param entry entry
     */
    saveUsingPOST1(params: { entry: StreakEntry;  }): (fetch: FetchAPI, basePath?: string) => Promise<StreakEntry> {
        const fetchArgs = StreakentrycontrollerApiFetchParamCreactor.saveUsingPOST1(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * StreakentrycontrollerApi - object-oriented interface
 */
export class StreakentrycontrollerApi extends BaseAPI {
    /** 
     * all
     */
    allUsingGET1() {
        return StreakentrycontrollerApiFp.allUsingGET1()(this.fetch, this.basePath);
    }
    /** 
     * delete
     * @param id id
     */
    deleteUsingDELETE1(params: {  id: number; }) {
        return StreakentrycontrollerApiFp.deleteUsingDELETE1(params)(this.fetch, this.basePath);
    }
    /** 
     * save
     * @param entry entry
     */
    saveUsingPOST1(params: {  entry: StreakEntry; }) {
        return StreakentrycontrollerApiFp.saveUsingPOST1(params)(this.fetch, this.basePath);
    }
};

/**
 * StreakentrycontrollerApi - factory interface
 */
export const StreakentrycontrollerApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * all
         */
        allUsingGET1() {
            return StreakentrycontrollerApiFp.allUsingGET1()(fetch, basePath);
        },
        /** 
         * delete
         * @param id id
         */
        deleteUsingDELETE1(params: {  id: number; }) {
            return StreakentrycontrollerApiFp.deleteUsingDELETE1(params)(fetch, basePath);
        },
        /** 
         * save
         * @param entry entry
         */
        saveUsingPOST1(params: {  entry: StreakEntry; }) {
            return StreakentrycontrollerApiFp.saveUsingPOST1(params)(fetch, basePath);
        },
    }
};


/**
 * UsercontrollerApi - fetch parameter creator
 */
export const UsercontrollerApiFetchParamCreactor = {
    /** 
     * all
     */
    allUsingGET2(): FetchArgs {
        const baseUrl = `/users`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * delete
     * @param id id
     */
    deleteUsingDELETE2(params: {  id: number; }): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteUsingDELETE2");
        }
        const baseUrl = `/users/{id}`
            .replace(`{${"id"}}`, `${ params.id }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * get
     * @param id id
     */
    getUsingGET1(params: {  id: number; }): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getUsingGET1");
        }
        const baseUrl = `/users/{id}`
            .replace(`{${"id"}}`, `${ params.id }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * save
     * @param user user
     */
    saveUsingPOST2(params: {  user: User; }): FetchArgs {
        // verify required parameter "user" is set
        if (params["user"] == null) {
            throw new Error("Missing required parameter user when calling saveUsingPOST2");
        }
        const baseUrl = `/users`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["user"]) {
            fetchOptions.body = JSON.stringify(params["user"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * UsercontrollerApi - functional programming interface
 */
export const UsercontrollerApiFp = {
    /** 
     * all
     */
    allUsingGET2(): (fetch: FetchAPI, basePath?: string) => Promise<Array<User>> {
        const fetchArgs = UsercontrollerApiFetchParamCreactor.allUsingGET2();
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * delete
     * @param id id
     */
    deleteUsingDELETE2(params: { id: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsercontrollerApiFetchParamCreactor.deleteUsingDELETE2(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * get
     * @param id id
     */
    getUsingGET1(params: { id: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<User> {
        const fetchArgs = UsercontrollerApiFetchParamCreactor.getUsingGET1(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * save
     * @param user user
     */
    saveUsingPOST2(params: { user: User;  }): (fetch: FetchAPI, basePath?: string) => Promise<User> {
        const fetchArgs = UsercontrollerApiFetchParamCreactor.saveUsingPOST2(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UsercontrollerApi - object-oriented interface
 */
export class UsercontrollerApi extends BaseAPI {
    /** 
     * all
     */
    allUsingGET2() {
        return UsercontrollerApiFp.allUsingGET2()(this.fetch, this.basePath);
    }
    /** 
     * delete
     * @param id id
     */
    deleteUsingDELETE2(params: {  id: number; }) {
        return UsercontrollerApiFp.deleteUsingDELETE2(params)(this.fetch, this.basePath);
    }
    /** 
     * get
     * @param id id
     */
    getUsingGET1(params: {  id: number; }) {
        return UsercontrollerApiFp.getUsingGET1(params)(this.fetch, this.basePath);
    }
    /** 
     * save
     * @param user user
     */
    saveUsingPOST2(params: {  user: User; }) {
        return UsercontrollerApiFp.saveUsingPOST2(params)(this.fetch, this.basePath);
    }
};

/**
 * UsercontrollerApi - factory interface
 */
export const UsercontrollerApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * all
         */
        allUsingGET2() {
            return UsercontrollerApiFp.allUsingGET2()(fetch, basePath);
        },
        /** 
         * delete
         * @param id id
         */
        deleteUsingDELETE2(params: {  id: number; }) {
            return UsercontrollerApiFp.deleteUsingDELETE2(params)(fetch, basePath);
        },
        /** 
         * get
         * @param id id
         */
        getUsingGET1(params: {  id: number; }) {
            return UsercontrollerApiFp.getUsingGET1(params)(fetch, basePath);
        },
        /** 
         * save
         * @param user user
         */
        saveUsingPOST2(params: {  user: User; }) {
            return UsercontrollerApiFp.saveUsingPOST2(params)(fetch, basePath);
        },
    }
};

